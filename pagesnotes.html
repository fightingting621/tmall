软件：
Bootstrap学习布局下载安装一下
网站：
www.jquerymobile.com
豆瓣API
birdio
Zeptojs
书：
js高级程序设计






1.下划线设置：text-decoration:none(无下划线)  text-decoration:under-line
2.去掉默认a标签字前面的那个点用：list-style:none
3.设置三角形:content:"";
            width:0;
            border:5px solid transparent;
            border-top-color:red;
4.虚线：把border里面的solid改成dashed
5.定位：absolute是指相对于body的定位，relative是相对于他自己本来的位置定位，fixed一般是指把某个东西固定在某个位置





js:
1.所有js代码都要写在script里面,script要放在body最下面
2.对象才能.属性，数组不行，如果要用写array【0】转换成对象之后才可以.属性
3.属性一定要有值，方法不一定
4.所有css里面的东西在js里面都要先.style再继续
5.类名可以相同有几个，id同名的只有他自己一个
6.e.clientX，e.clientY表示鼠标选中该点的横纵坐标
7.&gt;代表“>”,&lt;代表“<”
8.cursor: pointer;表示滑入鼠标变成小手  help变问号 wait加载 move四个小箭头那个
9.parseInt转换成数值型；
10.属性要加引号（规范）；
11.用var定义的变量才有变量提升问题，先定义后赋值会
12.局部变量全局不能调用，但全局变量局部可以调用
13.局部变量先调用后var定义，外面有一个全局相同变量被定义，会显示undefined，因为变量提升
14.用var定义，只要不在函数里面，都是全局变量


jq:
1.遇到selected，checked，加属性时用prop;（用attr只能好使一次）
2.<br/>表示换行
3.对象$里面不用引号，选择器才用
4.find找后代，children找儿子
5.target
6.不平铺：no-repeat
7.报错404，代表引入东西没找到，浏览器报404，说明网址没有找到；



移动端:
1.子元素设置大小为某em,em前面的数*父元素（爷爷以上也算）fontsize=真实px,font-size浏览器中最小12，小于12按照12算，可继承
rem是相对于根元素（html）
2.Bootstrap学习布局
3.宽高比是相对于父元素的，padding-top=百分数=（高/宽）=相对于父元素的宽
4.3vw当前可视宽域的百分之3，3vh当前可视高度的百分之3
5.双击=click单击两次在300ms内，用tap没有300ms延时，但是要引入zepto还有它里面包括tap的touch包
6.tap有点透事件，swipe（left right up down）滑动事件必须大于30像素才能触发
7.怪异盒模型，会把边框算里面  box-sizing:border-box(把border算在里面了，把内容区挤小了)

ES6(写在script里面)
1.let定义的东西不能变量提升，必须定义赋值之后再调用；
2.let定义的变量不能重复声明，但可以重复赋值，后赋值的会覆盖上一个；
3.let在某作用域中定义，如果在他之前调用报错，就算外面有也不好使。
4.块级作用域，任何一个大括号都是一个单独的作用域（for循环，if语句）外面用不了，可以直接放个大括号，也是一个语法。
5.一个外部函数里面声明了一个内部函数，内部函数里面再调用了外部函数的局部变量，这个时候，局部变量不会被释放。
6.函数立即调用（function（）{}）（），只能调用一次，定义完立即调用
7.内存泄漏：内存不被释放—>长期结果内存溢出，闭包容易造成内存泄漏
8.const:定义常量，它定义的后面不能重新定义也改不了，如果里面的东西不是数字而是对象{}，则可以改，因为地址没变，只是内容变了。加上Object.freeze（NUM）,则NUM不变改不了，let所有特性和它一样
9.块级作用域只有在let和const里面才好使
10.箭头函数里面的this是定义时指向（就是说箭头函数里面没有this指向，应该找他上层的那个），普通函数里面的this是运行时指向，一般匿名函数里面的this你想要的都是外面的那个大多数都用箭头函数
11.箭头函数里面没有arguements（普通函数里面不放参数相传参数要用的那个），箭头函数没有构造函数就不能new一个新的
12.window里面本身就有一个name属性，属性的值为空
13.call方法改变this指向，对应函数里面的this，this对应call里面第一个参数
14.apply与call相似，第一个参数是o，第二个是数组，数组里面可以放多个元素与函数里面的变量相对应传值
15.bind改变this指向，但不会直接调用，他应该再返回一个新的函数，然后调用那个新的函数就出来了，也可以函数立即执行去代替返回新的函数，传值的时候一个一个传和call一样
16.rest与扩展运算符作用相反
17.数组里面的值为undefined或者，，才显示默认值，不要谁就不赋值留个， ，就好或者在后面直接不写
18.[]数组有顺序，靠下标去找，{}对象没有顺序，靠名字找
19.解构：把数组和对象按照相应的关系拆开对应赋值，把结构解开
20.对象里面不能直接写数字，要有属性和值
21.扩展运算符（...）是把一些东西或者几个东西变成数组，解构是把结构解开
22.数组长度用.length    set，map长度用．size  set成立的是集合，里面不能存重复值，只显示一个
23.Set和数组相似，Map和对象相似，普通对象的键值只能是字符串，map的键值可以是任何类型，如果键值想要用数组或者对象{}，每次都要定义一下，因为数组和数组不一样
24.map其他的和set几乎相似
25.symbol是一个独一无二的值，永远不一样，通常用他做一个对象属性，因为对象的属性也是独一无二的
26.GUID全球唯一标识符（不是es6的内容，只是突然讲到，可以查百度）
27.``模板字符串，可以识别回车和空格，${}可以在大括号里面直接拼接，可以写表达式，可以判断，可以写字符串，如果字符串被定义了可以直接写那个变量，不能for循环啥的
28.repeat(3),重复输出三遍
29.object      对象属性的简写：对象只有属性名没有属性值时，他的值默认为与他的属性名同名的变量的值；
30.动态属性和对象属性的简写不能一起用，会报错     Object.assign是浅拷贝，会把原来的值也改掉
31.两个等号不相等，三个等号一定不相等 ，三个等号里面NaN不等，+0 -0相等     Object is与三个等号一个意思，又判断值也判断类型，只是在-0和+0还有NaN上做了变更，与三个等号相反
32.给数组定义一个函数，只要写在他的数组的原型上写个函数就可以啦
33.谁调用函数，this就指向谁
34.number Number.parseInt模块化封装，用途是比直接parseInt（也就是window.parseInt）避免污染全局变量还有Number.isNaN(parseFloat,parseInt)
35.isNaN()是不是非字符,number.isNaN()是判断括号里面的是不是NaN
36.Number.isFinite（）判断是否是一个数Number.isInteger是不是整型
37.Math。sign（）在括号里面写正数返回1，负数返回-1,0返回0；Math.trunc()向下取整与Math.floor一样相反的为Math.ceil()向上取整
38.Array.from(),把类数组转化成真的数组，把对象转化成数组，输入按照下标找，所以属性名设成数字，设成字母什么的就是undefined必须要在对象{}里面写上数组长度（length：8就是组成一个长度为8的数组）
39.数组可以转化成set，二维数组才可以转化成map.set,map都可以和数组进行转化，同样map转化成的就是一个二维数组
40.arr.forEach前面输出的是值，后面是输出的索引，并且他没有返回值，执行完就拉倒    arr.map与forEach输出的东西一样，但它有返回值，可以返回自己想要的东西，进来几个值返回出去的就是几个值可以return xx+5就是每一个数值加5，原数组不变arr.filter输出都是一样的，他有返回值，满足条件返回的是他原来的值，改变过程只为了过滤出原来函数中满足这个条件的数,他们里面有三个参数，第一个是数值，第二个是索引，第三个是数组本身
41.ajax:        JSON.parse（）把对象结构的字符串转化成对象，JSON.stringify()把对象转换成字符串
42.jquery里面用 $.get("a.json"//1.url请求路径,{
name:"zs"
}//2.参数,function(){}//3.回调，成功了自动调用这个函数,"json(或text或者html)"//4.返回类型）；
43.promise     resolve(); 返回成功状态的promise对象  reject（）；返回失败状态的promise对象
44.p.then里面是两个函数，一个成功一个失败，成功调用第一个，失败调用第二个。第二个可以不写函数，写成catch方法
45.Promise.all()  状态都成功了，按照最长的时间把其他成功的一起输出成为一个数组（一般是这种需求需要用这个函数），如果有一个失败了，就调用失败函数，成功的不管了，但仍然执行，拿出失败中时间最短的那个
46.Promise.race()  状态都成功了，谁最快先调用谁的，竞速 ，不管成功失败，我只要速度最快那个，成功就调用成功函数，失败就调用失败函数，哪个快要哪个
47.setTimeout不阻滞代码执行，所以他们一起执行
48.promise用同步方式解决异步问题，一旦状态成功或者失败不可再修改，永远都是这个状态，异步主要就是不阻碍后面代码的执行，p.then要把上面东西执行之后返回p再执行下面的函数
49.自己本身带有处理失败的防范就先用自己的，没有再找catch的